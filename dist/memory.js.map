{"version":3,"sources":["../src/memory.js"],"names":["MEM_OPTS","MemMonitor","options","opts","top","spawn","process","env","NODE_ENV","onData","onExit","stdout","on","data","parseData","toString","kill","memUsage","parseMemUsage","emit","topMemProcs","parseTopMemProcs","usage","lines","split","regex","forEach","line","matches","exec","length","used","wired","unused","used_kb","parseMemInKb","wired_kb","unused_kb","procs","push","pid","mem","command","trim","num","Number","substring","charAt"],"mappings":"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","file":"memory.js","sourcesContent":["import { EventEmitter } from 'events';\nimport { parseOptions } from './utils';\nimport child_process from 'child_process';\n\nconst MEM_OPTS = ['-stats', 'pid,mem,command', '-o', 'mem'];\n\nexport default class MemMonitor extends EventEmitter {\n    constructor(options) {\n        super();\n\n        this.opts = parseOptions(MEM_OPTS, options);\n        this.top = child_process.spawn('/usr/bin/top', this.opts);\n\n        if (process.env.NODE_ENV !== 'test') {\n            this.onData();\n        }\n\n        this.onExit();\n    }\n\n    onData() {\n        this.top.stdout.on('data', (data) => {\n            this.parseData(data.toString());\n        });\n    }\n\n    onExit() {\n        this.on('exit', () => {\n            this.top.kill('SIGINT');\n        });\n    }\n\n    parseData(data) {\n        const memUsage = this.parseMemUsage(data);\n\n        if (memUsage) {\n            this.emit('memUsage', memUsage);\n        }\n\n        const topMemProcs = this.parseTopMemProcs(data);\n\n        if (topMemProcs) {\n            this.emit('topMemProcs', topMemProcs);\n        }\n    }\n\n    parseMemUsage(data) {\n        let usage;\n        const lines = data.split('\\n');\n        const regex = / +(\\d+.) +used.*\\((\\d+.) +wired.* *(\\d+.) *unused/;\n\n        lines.forEach((line) => {\n            const matches = regex.exec(line);\n\n            if (matches && matches.length >= 3) {\n                usage = {\n                    used: matches[1],\n                    wired: matches[2],\n                    unused: matches[3],\n                    used_kb: this.parseMemInKb(matches[1]),\n                    wired_kb: this.parseMemInKb(matches[2]),\n                    unused_kb: this.parseMemInKb(matches[3])\n                };\n            }\n        });\n\n        return usage;\n    }\n\n    parseTopMemProcs(data) {\n        const procs = [];\n        const regex = /^(\\d+)\\s+(\\w+).?\\s+(.*)$/mg;\n        let matches = regex.exec(data);\n\n        while (matches) {\n            if (!matches || matches.length < 4) continue;\n\n            procs.push({\n                pid: matches[1],\n                mem: matches[2],\n                command: matches[3].trim()\n            });\n\n            matches = regex.exec(data);\n        }\n\n        return procs;\n    }\n\n    parseMemInKb(mem) {\n        const num = Number(mem.substring(0, mem.length-1));\n\n        if (mem.charAt(mem.length-1) === 'M') {\n            return num * 1024;\n        }\n        else if (mem.charAt(mem.length-1) === 'G') {\n            return num * 1024 * 1024;\n        }\n        else if (mem.charAt(mem.length-1) === 'K') {\n            return num;\n        }\n    }\n}"]}